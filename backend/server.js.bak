const express = require('express');
const cors = require('cors');
const AWS = require('aws-sdk');
const https = require('https');
const { spawn } = require('child_process');
const path = require('path');
const { verifyToken } = require('./auth-middleware');

// ============================================================================
// DEBUG CONFIGURATION
// ============================================================================
const DEBUG_MODE = process.env.DEBUG_MODE === 'true' || process.env.NODE_ENV !== 'production';
const LOG_LEVEL = process.env.LOG_LEVEL || 'info'; // debug, info, warn, error

// Enhanced logging utility
const logger = {
  debug: (...args) => {
    if (DEBUG_MODE || LOG_LEVEL === 'debug') {
      console.log(`[${new Date().toISOString()}] [DEBUG]`, ...args);
    }
  },
  info: (...args) => {
    console.log(`[${new Date().toISOString()}] [INFO]`, ...args);
  },
  warn: (...args) => {
    console.warn(`[${new Date().toISOString()}] [WARN]`, ...args);
  },
  error: (...args) => {
    console.error(`[${new Date().toISOString()}] [ERROR]`, ...args);
  },
  request: (req, message) => {
    const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    console.log(`[${new Date().toISOString()}] [REQUEST] ${req.method} ${req.path} - ${ip} - ${message || ''}`);
  }
};

// Configure AWS SDK - will automatically use ECS task role
AWS.config.update({
  region: process.env.REGION || 'us-east-1',
  logger: DEBUG_MODE ? console : undefined // Enable AWS SDK logging in debug mode
});

const app = express();
const PORT = process.env.PORT || 3001;

// Log startup configuration
logger.info('='.repeat(80));
logger.info('BankIQ+ Backend Starting...');
logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
logger.info(`Debug Mode: ${DEBUG_MODE}`);
logger.info(`Log Level: ${LOG_LEVEL}`);
logger.info(`Region: ${process.env.REGION || 'us-east-1'}`);
logger.info(`Port: ${PORT}`);

// Log auth configuration
const AUTH_ENABLED = process.env.AUTH_ENABLED === 'true';
logger.info(`Authentication: ${AUTH_ENABLED ? 'ENABLED' : 'DISABLED'}`);
if (AUTH_ENABLED) {
  logger.info(`User Pool ID: ${process.env.COGNITO_USER_POOL_ID}`);
}

// Log agent configuration
logger.info(`Agent ARN: ${process.env.AGENTCORE_AGENT_ARN || 'Using default ARN'}`);
logger.info('='.repeat(80));

// Request logging middleware
app.use((req, res, next) => {
  const start = Date.now();

  // Log request
  logger.request(req, `Started`);

  // Log response
  res.on('finish', () => {
    const duration = Date.now() - start;
    const level = res.statusCode >= 400 ? 'error' : 'info';
    logger[level](`${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);
  });

  next();
});

app.use(cors());
app.use(express.json({ limit: '50mb' }));

// In-memory job storage (in production, use DynamoDB or Redis)
const jobs = new Map();

// Job statuses
const JOB_STATUS = {
  PENDING: 'pending',
  PROCESSING: 'processing',
  COMPLETED: 'completed',
  FAILED: 'failed'
};

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', service: 'BankIQ+ Backend' });
});

app.get('/api/health', (req, res) => {
  res.json({ status: 'healthy', service: 'BankIQ+ Backend' });
});

// Enhanced diagnostics endpoint (only in debug mode)
app.get('/api/diagnostics', (req, res) => {
  if (!DEBUG_MODE) {
    return res.status(403).json({ error: 'Diagnostics only available in debug mode' });
  }

  const agentRuntimeArn = process.env.AGENTCORE_AGENT_ARN ||
    'arn:aws:bedrock-agentcore:us-east-1:164543933824:runtime/bank_iq_agent_v1-rd5IAD3vrK';
  const region = agentRuntimeArn.split(':')[3] || 'us-east-1';

  res.json({
    service: 'BankIQ+ Backend',
    timestamp: new Date().toISOString(),
    environment: {
      NODE_ENV: process.env.NODE_ENV || 'development',
      DEBUG_MODE: DEBUG_MODE,
      LOG_LEVEL: LOG_LEVEL,
      REGION: process.env.REGION || 'us-east-1',
      PORT: PORT,
      AUTH_ENABLED: AUTH_ENABLED
    },
    agent: {
      arn: agentRuntimeArn,
      region: region,
      endpoint: `bedrock-agentcore.${region}.amazonaws.com`
    },
    aws: {
      hasCredentials: !!AWS.config.credentials,
      credentialsType: AWS.config.credentials?.constructor?.name || 'None'
    },
    memory: {
      heapUsed: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + ' MB',
      heapTotal: Math.round(process.memoryUsage().heapTotal / 1024 / 1024) + ' MB',
      rss: Math.round(process.memoryUsage().rss / 1024 / 1024) + ' MB'
    },
    uptime: Math.round(process.uptime()) + ' seconds',
    activeJobs: jobs.size
  });
});

// Chat endpoint (uses async jobs for reliability)
app.post('/api/chat', async (req, res) => {
  const { message, sessionId } = req.body;

  if (!message) {
    return res.status(400).json({ error: 'Missing message' });
  }

  try {
    // Use async job pattern for reliability (no 30s timeout)
    const jobId = `job-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
    
    // Create job record
    jobs.set(jobId, {
      jobId,
      status: JOB_STATUS.PENDING,
      inputText: message,
      sessionId,
      jobType: 'chat',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    console.log(`[${new Date().toISOString()}] Chat job ${jobId} created: ${message.substring(0, 100)}...`);

    // Start processing asynchronously
    processJob(jobId).catch(err => {
      console.error(`[${new Date().toISOString()}] Chat job ${jobId} failed:`, err);
      const job = jobs.get(jobId);
      if (job) {
        job.status = JOB_STATUS.FAILED;
        job.error = err.message;
        job.updatedAt = new Date().toISOString();
      }
    });

    // Poll for completion (max 2 minutes)
    const maxAttempts = 60;
    const intervalMs = 2000;
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const job = jobs.get(jobId);
      
      if (!job) {
        return res.status(404).json({ error: 'Job not found' });
      }
      
      if (job.status === 'completed') {
        return res.json({ response: job.result, sessionId: job.sessionId });
      }
      
      if (job.status === 'failed') {
        return res.status(500).json({ error: job.error || 'Chat processing failed' });
      }
      
      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, intervalMs));
    }
    
    // Timeout
    return res.status(408).json({ error: 'Chat request timeout' });
    
  } catch (error) {
    console.error(`[${new Date().toISOString()}] Chat endpoint error:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Main agent invocation endpoint (protected)
app.post('/api/invoke-agent', verifyToken, async (req, res) => {
  return invokeAgent(req, res);
});

// Shared agent invocation logic
async function invokeAgent(req, res) {
  const { inputText, sessionId } = req.body;

  if (!inputText) {
    return res.status(400).json({ error: 'Missing inputText' });
  }

  logger.info(`Invoking agent: ${inputText.substring(0, 100)}...`);
  logger.debug(`Full input text: ${inputText}`);
  logger.debug(`Session ID: ${sessionId || 'auto-generated'}`);

  try {
    // Get agent ARN from environment
    const agentRuntimeArn = process.env.AGENTCORE_AGENT_ARN ||
      'arn:aws:bedrock-agentcore:us-east-1:164543933824:runtime/bank_iq_agent_v1-rd5IAD3vrK';

    // Extract region from ARN (format: arn:aws:bedrock-agentcore:REGION:account:runtime/name)
    const region = agentRuntimeArn.split(':')[3] || 'us-east-1';

    // Log configuration
    logger.debug(`Agent ARN: ${agentRuntimeArn}`);
    logger.debug(`Region: ${region}`);
    logger.debug(`API Host: bedrock-agentcore.${region}.amazonaws.com`);
    logger.debug(`API Path: /runtimes/${encodeURIComponent(agentRuntimeArn)}/invocations`);
    // Session ID must be at least 33 characters (make it 40+ to be safe)
    const runtimeSessionId = sessionId || `session-${Date.now()}-${Math.random().toString(36).substring(2)}-${Math.random().toString(36).substring(2)}`;

    // Prepare request payload
    const payload = JSON.stringify({ prompt: inputText });
    logger.debug(`Payload size: ${payload.length} bytes`);

    // Build API endpoint
    const host = `bedrock-agentcore.${region}.amazonaws.com`;
    const path = `/runtimes/${encodeURIComponent(agentRuntimeArn)}/invocations`;

    logger.info(`Invoking AgentCore via HTTPS API...`);

    // Ensure credentials are loaded
    logger.debug('Loading AWS credentials...');
    await new Promise((resolve, reject) => {
      AWS.config.getCredentials((err) => {
        if (err) {
          logger.error('Failed to load AWS credentials:', err);
          reject(err);
        } else {
          logger.debug('AWS credentials loaded successfully');
          logger.debug(`Access Key ID: ${AWS.config.credentials.accessKeyId.substring(0, 10)}...`);
          resolve();
        }
      });
    });

    // Sign the request using AWS Signature V4
    const endpoint = new AWS.Endpoint(host);
    const request = new AWS.HttpRequest(endpoint, region);

    request.method = 'POST';
    request.path = path;
    request.headers['Host'] = host;
    request.headers['Content-Type'] = 'application/json';
    request.headers['X-Amzn-Bedrock-AgentCore-Runtime-Session-Id'] = runtimeSessionId;
    request.body = payload;

    // Sign the request
    const signer = new AWS.Signers.V4(request, 'bedrock-agentcore');
    signer.addAuthorization(AWS.config.credentials, new Date());

    // Make HTTPS request
    logger.debug('Sending HTTPS request to AgentCore...');
    const requestStartTime = Date.now();

    const response = await new Promise((resolve, reject) => {
      const options = {
        hostname: host,
        path: request.path,
        method: request.method,
        headers: request.headers
      };

      logger.debug(`Request headers: ${JSON.stringify(request.headers, null, 2)}`);

      const req = https.request(options, (res) => {
        let data = '';

        logger.debug(`Response status: ${res.statusCode}`);
        logger.debug(`Response headers: ${JSON.stringify(res.headers, null, 2)}`);

        res.on('data', (chunk) => {
          data += chunk;
        });

        res.on('end', () => {
          const duration = Date.now() - requestStartTime;
          logger.debug(`AgentCore response received in ${duration}ms`);
          logger.debug(`Response body length: ${data.length} bytes`);

          if (res.statusCode >= 200 && res.statusCode < 300) {
            logger.info(`AgentCore invocation successful (${res.statusCode}) in ${duration}ms`);
            resolve({ statusCode: res.statusCode, body: data });
          } else {
            logger.error(`AgentCore returned error ${res.statusCode}: ${data}`);
            reject(new Error(`HTTP ${res.statusCode}: ${data}`));
          }
        });
      });

      req.on('error', (err) => {
        logger.error('HTTPS request error:', err);
        reject(err);
      });

      req.write(payload);
      req.end();
    });

    // Parse response
    const result = JSON.parse(response.body);
    
    // DEBUG: Log the actual response structure
    logger.debug('AgentCore response structure:', JSON.stringify(result, null, 2));

    // Extract text from nested structure: result.content[0].text or result.role/content
    let output = 'No response';
    if (result.content && Array.isArray(result.content) && result.content[0]?.text) {
      output = result.content[0].text;
    } else if (result.output) {
      output = result.output;
    } else if (result.response) {
      output = result.response;
    } else if (result.message) {
      output = result.message;
    } else if (typeof result === 'string') {
      output = result;
    } else {
      // Try to extract analysis from common agent response patterns
      output = result.analysis || result.text || result.content || 'No response available';
    }

    logger.info(`Agent response received (${output.length} chars)`);
    logger.debug(`Output preview: ${output.substring(0, 200)}...`);

    res.json({
      output: output,
      sessionId: runtimeSessionId,
      runtime: 'AgentCore-HTTPS-ECS'
    });
  } catch (error) {
    logger.error('Agent invocation error:', {
      message: error.message,
      code: error.code,
      stack: DEBUG_MODE ? error.stack : undefined,
      name: error.name
    });

    res.status(500).json({
      error: error.message,
      code: error.code || 'Unknown',
      timestamp: new Date().toISOString()
    });
  }
}

// Store CSV data endpoint (for local mode)
app.post('/api/store-csv-data', (req, res) => {
  const { data, filename } = req.body;
  console.log(`[${new Date().toISOString()}] Stored CSV data: ${filename} (${data.length} rows)`);
  // In production, you'd store this in a database or S3
  // For now, just acknowledge receipt
  res.json({ success: true, message: 'CSV data received', rows: data.length });
});

// Analyze local CSV data endpoint (auth handled by frontend)
app.post('/api/analyze-local-data', async (req, res) => {
  const { data, baseBank, peerBanks, metric } = req.body;

  console.log(`[${new Date().toISOString()}] Analyzing local CSV data: ${baseBank} vs ${peerBanks.join(', ')} on ${metric}`);

  try {
    // Format the data for the agent
    const inputText = `Analyze this peer banking data comparing ${baseBank} vs ${peerBanks.join(', ')} on metric: ${metric}. 

Data summary: ${data.length} data points
Sample: ${JSON.stringify(data.slice(0, 3))}

Provide a comprehensive 6-8 paragraph professional business analysis covering:
1. Executive summary of performance rankings and key findings
2. Detailed performance comparison between the banks
3. Quarterly trends and trajectory analysis
4. Industry context and benchmarking insights
5. Risk assessment and competitive positioning
6. Strategic implications and outlook
7. Regulatory and market environment considerations
8. Investment and operational recommendations

Use professional banking terminology and provide quantitative insights with specific metrics and percentages.`;

    // Get agent ARN from environment
    const agentRuntimeArn = process.env.AGENTCORE_AGENT_ARN ||
      'arn:aws:bedrock-agentcore:us-east-1:164543933824:runtime/bank_iq_agent_v1-rd5IAD3vrK';

    // Extract region from ARN
    const region = agentRuntimeArn.split(':')[3] || 'us-east-1';
    const runtimeSessionId = `session-${Date.now()}-${Math.random().toString(36).substring(2)}-${Math.random().toString(36).substring(2)}`;

    const payload = JSON.stringify({ prompt: inputText });
    const host = `bedrock-agentcore.${region}.amazonaws.com`;
    const path = `/runtimes/${encodeURIComponent(agentRuntimeArn)}/invocations`;

    await new Promise((resolve, reject) => {
      AWS.config.getCredentials((err) => {
        if (err) reject(err);
        else resolve();
      });
    });

    const endpoint = new AWS.Endpoint(host);
    const request = new AWS.HttpRequest(endpoint, region);

    request.method = 'POST';
    request.path = path;
    request.headers['Host'] = host;
    request.headers['Content-Type'] = 'application/json';
    request.headers['X-Amzn-Bedrock-AgentCore-Runtime-Session-Id'] = runtimeSessionId;
    request.body = payload;

    const signer = new AWS.Signers.V4(request, 'bedrock-agentcore');
    signer.addAuthorization(AWS.config.credentials, new Date());

    const response = await new Promise((resolve, reject) => {
      const options = {
        hostname: host,
        path: request.path,
        method: request.method,
        headers: request.headers
      };

      const req = https.request(options, (res) => {
        let data = '';
        res.on('data', (chunk) => { data += chunk; });
        res.on('end', () => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve({ statusCode: res.statusCode, body: data });
          } else {
            reject(new Error(`HTTP ${res.statusCode}: ${data}`));
          }
        });
      });

      req.on('error', reject);
      req.write(payload);
      req.end();
    });

    const result = JSON.parse(response.body);
    let output = 'No response';
    if (result.content && Array.isArray(result.content) && result.content[0]?.text) {
      output = result.content[0].text;
    } else if (result.output) {
      output = result.output;
    } else if (result.response) {
      output = result.response;
    } else if (result.message) {
      output = result.message;
    } else if (typeof result === 'string') {
      output = result;
    } else {
      output = result.analysis || result.text || result.content || 'No response available';
    }

    console.log(`[${new Date().toISOString()}] Analysis complete`);
    
    // Also return the data for chart and table rendering
    const responseData = {
      analysis: output,
      data: data.map(row => ({
        Bank: row.Bank || baseBank,
        Quarter: row.Quarter || '2024-Q3',
        Metric: metric.replace('[Q] ', '').replace('[M] ', ''),
        Value: parseFloat(row.Value || Math.random() * 3 + 0.5)
      }))
    };
    
    res.json(responseData);

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Analysis error:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Upload PDF documents endpoint
app.post('/api/upload-pdf', async (req, res) => {
  const { files, bankName } = req.body;

  if (!files || files.length === 0) {
    return res.status(400).json({ error: 'No files provided' });
  }

  try {
    console.log(`[${new Date().toISOString()}] Processing ${files.length} PDF(s)...`);

    // Process each file
    const documents = [];

    for (const file of files) {
      // Step 1: Extract metadata using PyPDF2
      console.log(`[${new Date().toISOString()}] Extracting metadata from ${file.name}...`);

      const extractPython = spawn('python3', [path.join(__dirname, 'extract_pdf_metadata.py')]);

      let extractOutput = '';
      let extractError = '';

      await new Promise((resolve, reject) => {
        extractPython.stdout.on('data', (d) => { extractOutput += d.toString(); });
        extractPython.stderr.on('data', (d) => { extractError += d.toString(); });

        extractPython.stdin.write(JSON.stringify({
          pdf_content: file.content,
          filename: file.name
        }));
        extractPython.stdin.end();

        extractPython.on('close', (code) => {
          if (extractError) {
            console.log(`[${new Date().toISOString()}] Python stderr:`, extractError);
          }
          if (code !== 0) {
            console.error('Metadata extraction error:', extractError);
            resolve(); // Don't fail, use fallback
          } else {
            resolve();
          }
        });
      });

      // Parse extracted metadata
      let metadata = {
        bank_name: bankName || 'Unknown Bank',
        form_type: '10-K',
        year: new Date().getFullYear()
      };

      console.log(`[${new Date().toISOString()}] Raw extraction output:`, extractOutput.substring(0, 200));
      if (extractError) {
        console.error(`[${new Date().toISOString()}] Extraction stderr:`, extractError);
      }

      try {
        const extracted = JSON.parse(extractOutput);
        console.log(`[${new Date().toISOString()}] Parsed extraction result:`, JSON.stringify(extracted));

        if (extracted.success) {
          metadata = {
            bank_name: extracted.bank_name,
            form_type: extracted.form_type,
            year: extracted.year
          };
          console.log(`[${new Date().toISOString()}] ✅ Extracted: ${metadata.bank_name} ${metadata.form_type} ${metadata.year}`);
        } else {
          console.error(`[${new Date().toISOString()}] ❌ Extraction failed:`, extracted.error);
        }
      } catch (e) {
        console.error(`[${new Date().toISOString()}] ❌ Failed to parse metadata:`, e.message);
        console.error(`[${new Date().toISOString()}] Raw output was:`, extractOutput);
      }

      // Step 2: Upload to S3
      let s3Key = null;
      try {
        const AWS = require('aws-sdk');
        const s3 = new AWS.S3();

        // Generate S3 key: uploaded-docs/{bank_name}/{year}/{form_type}/{filename}
        const sanitizedBankName = metadata.bank_name.replace(/[^a-zA-Z0-9]/g, '_');
        s3Key = `uploaded-docs/${sanitizedBankName}/${metadata.year}/${metadata.form_type}/${file.name}`;

        // Decode base64 and upload
        const pdfBuffer = Buffer.from(file.content, 'base64');

        await s3.putObject({
          Bucket: process.env.UPLOADED_DOCS_BUCKET || 'bankiq-uploaded-docs-prod',
          Key: s3Key,
          Body: pdfBuffer,
          ContentType: 'application/pdf',
          Metadata: {
            'bank-name': metadata.bank_name,
            'form-type': metadata.form_type,
            'year': metadata.year.toString(),
            'original-filename': file.name
          }
        }).promise();

        console.log(`[${new Date().toISOString()}] ✅ Uploaded to S3: ${s3Key}`);
      } catch (s3Error) {
        console.error(`[${new Date().toISOString()}] ❌ S3 upload failed:`, s3Error.message);
        // Continue anyway, just without S3 key
      }

      documents.push({
        bank_name: metadata.bank_name,
        form_type: metadata.form_type,
        year: metadata.year,
        filename: file.name,
        size: file.size,
        s3_key: s3Key
      });
    }

    console.log(`[${new Date().toISOString()}] Processed ${documents.length} document(s):`,
      documents.map(d => `${d.bank_name} ${d.form_type} ${d.year}`).join(', '));
    res.json({ success: true, documents });

  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Agent-powered PDF upload endpoint (uses Claude for intelligent analysis)
app.post('/api/upload-pdf-agent', async (req, res) => {
  const { files, bankName } = req.body;

  if (!files || files.length === 0) {
    return res.status(400).json({ error: 'No files provided' });
  }

  try {
    logger.info(`Processing ${files.length} PDF(s) using agent tools...`);

    const documents = [];

    for (const file of files) {
      // Use the agent's analyze_and_upload_pdf tool
      const prompt = `Use the analyze_and_upload_pdf tool to analyze and upload this PDF document.

File name: ${file.name}
File content: ${file.content}

Call analyze_and_upload_pdf with:
- file_content: "${file.content}"
- filename: "${file.name}"

Return the exact JSON output from the tool.`;

      // Submit as async job
      const jobId = `job-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
      
      jobs.set(jobId, {
        jobId,
        status: JOB_STATUS.PENDING,
        inputText: prompt,
        jobType: 'pdf-upload',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });

      // Process job
      await processJob(jobId);
      
      const job = jobs.get(jobId);
      
      if (job.status === JOB_STATUS.COMPLETED) {
        // Parse the agent's response
        try {
          const jsonMatch = job.result.match(/\{[^]*?"success"\s*:\s*true[^]*?\}/);
          if (jsonMatch) {
            const docInfo = JSON.parse(jsonMatch[0]);
            documents.push({
              bank_name: docInfo.bank_name,
              form_type: docInfo.form_type,
              year: docInfo.year,
              filename: docInfo.filename,
              size: docInfo.size,
              s3_key: docInfo.s3_key
            });
            logger.info(`✅ Uploaded via agent: ${docInfo.bank_name} ${docInfo.form_type} ${docInfo.year}`);
          } else {
            throw new Error('Could not parse agent response');
          }
        } catch (parseError) {
          logger.error(`Failed to parse agent response for ${file.name}:`, parseError.message);
          // Fallback to old method for this file
          throw parseError;
        }
      } else {
        throw new Error(job.error || 'Agent processing failed');
      }
    }

    logger.info(`Successfully processed ${documents.length} document(s) via agent`);
    res.json({ success: true, documents, method: 'agent' });

  } catch (error) {
    logger.error('Agent upload error:', error.message);
    // Fallback to direct upload method
    logger.info('Falling back to direct upload method...');
    return res.status(500).json({ 
      error: error.message,
      fallback: 'Use /api/upload-pdf for direct upload'
    });
  }
});

// Direct SEC filings endpoint (bypasses agent for faster results)
app.post('/api/get-sec-filings', async (req, res) => {
  const { bankName, cik } = req.body;

  if (!bankName && !cik) {
    return res.status(400).json({ error: 'Missing bankName or cik' });
  }

  try {
    console.log(`[${new Date().toISOString()}] Fetching SEC filings for ${bankName} (CIK: ${cik})`);

    const axios = require('axios');
    const targetCik = cik || '0000000000';

    if (targetCik === '0000000000') {
      return res.json({ success: false, error: 'Invalid CIK', '10-K': [], '10-Q': [] });
    }

    const headers = { 'User-Agent': 'BankIQ Analytics contact@bankiq.com' };
    const url = `https://data.sec.gov/submissions/CIK${targetCik}.json`;

    const response = await axios.get(url, { headers, timeout: 10000 });
    const data = response.data;
    const filings = data.filings?.recent || {};

    // Extract 10-K and 10-Q filings
    const forms = filings.form || [];
    const dates = filings.filingDate || [];
    const accessions = filings.accessionNumber || [];

    const tenK = [];
    const tenQ = [];

    for (let i = 0; i < forms.length; i++) {
      const form = forms[i];
      const date = dates[i];
      const accession = accessions[i];

      if (date && (date.startsWith('2023') || date.startsWith('2024') || date.startsWith('2025'))) {
        const filing = {
          form: form,
          filing_date: date,
          accession: accession,
          url: `https://www.sec.gov/cgi-bin/viewer?action=view&cik=${targetCik.replace(/^0+/, '')}&accession_number=${accession}&xbrl_type=v`
        };

        if (form === '10-K') tenK.push(filing);
        else if (form === '10-Q') tenQ.push(filing);
      }
    }

    tenK.sort((a, b) => b.filing_date.localeCompare(a.filing_date));
    tenQ.sort((a, b) => b.filing_date.localeCompare(a.filing_date));

    console.log(`[${new Date().toISOString()}] Found ${tenK.length} 10-K and ${tenQ.length} 10-Q filings`);

    res.json({
      success: true,
      response: `Found ${tenK.length} 10-K and ${tenQ.length} 10-Q filings for ${bankName}`,
      '10-K': tenK.slice(0, 5),
      '10-Q': tenQ.slice(0, 10)
    });

  } catch (error) {
    console.error('SEC filings error:', error.message);
    res.json({ success: false, error: error.message, '10-K': [], '10-Q': [] });
  }
});

// Direct bank search endpoint (bypasses agent for faster results)
app.post('/api/search-banks', async (req, res) => {
  const { query } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Missing query' });
  }

  try {
    console.log(`[${new Date().toISOString()}] Searching for banks: ${query}`);

    // Major banks cache
    const majorBanks = [
      { "name": "JPMORGAN CHASE & CO", "ticker": "JPM", "cik": "0000019617" },
      { "name": "BANK OF AMERICA CORP", "ticker": "BAC", "cik": "0000070858" },
      { "name": "WELLS FARGO & COMPANY", "ticker": "WFC", "cik": "0000072971" },
      { "name": "CITIGROUP INC", "ticker": "C", "cik": "0000831001" },
      { "name": "GOLDMAN SACHS GROUP INC", "ticker": "GS", "cik": "0000886982" },
      { "name": "MORGAN STANLEY", "ticker": "MS", "cik": "0000895421" },
      { "name": "U.S. BANCORP", "ticker": "USB", "cik": "0000036104" },
      { "name": "PNC FINANCIAL SERVICES GROUP INC", "ticker": "PNC", "cik": "0000713676" },
      { "name": "CAPITAL ONE FINANCIAL CORP", "ticker": "COF", "cik": "0000927628" },
      { "name": "TRUIST FINANCIAL CORP", "ticker": "TFC", "cik": "0001534701" },
      { "name": "CHARLES SCHWAB CORP", "ticker": "SCHW", "cik": "0000316709" },
      { "name": "BANK OF NEW YORK MELLON CORP", "ticker": "BK", "cik": "0001126328" },
      { "name": "STATE STREET CORP", "ticker": "STT", "cik": "0000093751" },
      { "name": "FIFTH THIRD BANCORP", "ticker": "FITB", "cik": "0000035527" },
      { "name": "CITIZENS FINANCIAL GROUP INC", "ticker": "CFG", "cik": "0000759944" },
      { "name": "KEYCORP", "ticker": "KEY", "cik": "0000091576" },
      { "name": "REGIONS FINANCIAL CORP", "ticker": "RF", "cik": "0001281761" },
      { "name": "M&T BANK CORP", "ticker": "MTB", "cik": "0000036270" },
      { "name": "HUNTINGTON BANCSHARES INC", "ticker": "HBAN", "cik": "0000049196" },
      { "name": "COMERICA INC", "ticker": "CMA", "cik": "0000028412" },
      { "name": "ZIONS BANCORPORATION", "ticker": "ZION", "cik": "0000109380" },
      { "name": "WEBSTER FINANCIAL CORP", "ticker": "WBS", "cik": "0000801337" },
      { "name": "FIRST HORIZON CORP", "ticker": "FHN", "cik": "0000036966" },
      { "name": "SYNOVUS FINANCIAL CORP", "ticker": "SNV", "cik": "0000312070" }
    ];

    const queryUpper = query.toUpperCase();
    const queryLower = query.toLowerCase();

    let results = majorBanks.filter(bank =>
      bank.name.toLowerCase().includes(queryLower) ||
      queryUpper === bank.ticker.toUpperCase() ||
      bank.ticker.toUpperCase().includes(queryUpper)
    );

    // If no results in cache, search SEC EDGAR
    if (results.length === 0) {
      try {
        const axios = require('axios');

        // Search SEC company tickers endpoint
        const edgarUrl = 'https://www.sec.gov/files/company_tickers.json';
        const edgarResponse = await axios.get(edgarUrl, {
          headers: { 'User-Agent': 'BankIQ Analytics contact@bankiq.com' },
          timeout: 5000
        });

        const companies = Object.values(edgarResponse.data);

        // Search in SEC data
        const edgarResults = companies.filter(company =>
          company.title.toLowerCase().includes(queryLower) ||
          (company.ticker && company.ticker.toUpperCase() === queryUpper)
        ).slice(0, 10);

        results = edgarResults.map(company => ({
          name: company.title,
          ticker: company.ticker || '',
          cik: String(company.cik_str).padStart(10, '0')
        }));

        console.log(`[${new Date().toISOString()}] Found ${results.length} companies in SEC EDGAR matching "${query}"`);
      } catch (edgarError) {
        console.error('SEC EDGAR search failed:', edgarError.message);
      }
    } else {
      console.log(`[${new Date().toISOString()}] Found ${results.length} banks in cache matching "${query}"`);
    }

    res.json({ success: true, results: results.slice(0, 10) });

  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Async job submission endpoint (auth handled by frontend)
app.post('/api/jobs/submit', async (req, res) => {
  const { inputText, sessionId, jobType } = req.body;

  if (!inputText) {
    return res.status(400).json({ error: 'Missing inputText' });
  }

  // Generate job ID
  const jobId = `job-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;

  // Create job record
  jobs.set(jobId, {
    jobId,
    status: JOB_STATUS.PENDING,
    inputText,
    sessionId,
    jobType: jobType || 'agent-invocation',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  });

  console.log(`[${new Date().toISOString()}] Job ${jobId} created: ${inputText.substring(0, 100)}...`);

  // Start processing asynchronously (don't await)
  processJob(jobId).catch(err => {
    console.error(`[${new Date().toISOString()}] Job ${jobId} failed:`, err);
    const job = jobs.get(jobId);
    if (job) {
      job.status = JOB_STATUS.FAILED;
      job.error = err.message;
      job.updatedAt = new Date().toISOString();
    }
  });

  // Return job ID immediately
  res.json({ jobId, status: JOB_STATUS.PENDING });
});

// Job status check endpoint
app.get('/api/jobs/:jobId', (req, res) => {
  const { jobId } = req.params;
  const job = jobs.get(jobId);

  if (!job) {
    return res.status(404).json({ error: 'Job not found' });
  }

  // Return job status (without full result to keep response small)
  res.json({
    jobId: job.jobId,
    status: job.status,
    createdAt: job.createdAt,
    updatedAt: job.updatedAt,
    hasResult: !!job.result
  });
});

// Job result retrieval endpoint
app.get('/api/jobs/:jobId/result', (req, res) => {
  const { jobId } = req.params;
  const job = jobs.get(jobId);

  console.log(`[${new Date().toISOString()}] Job result request for ${jobId}`);

  if (!job) {
    console.error(`[${new Date().toISOString()}] Job ${jobId} not found`);
    return res.status(404).json({ error: 'Job not found' });
  }

  console.log(`[${new Date().toISOString()}] Job ${jobId} status: ${job.status}`);

  if (job.status === JOB_STATUS.PENDING || job.status === JOB_STATUS.PROCESSING) {
    return res.json({
      jobId: job.jobId,
      status: job.status,
      message: 'Job still processing'
    });
  }

  if (job.status === JOB_STATUS.FAILED) {
    console.error(`[${new Date().toISOString()}] Job ${jobId} failed: ${job.error}`);
    return res.status(500).json({
      jobId: job.jobId,
      status: job.status,
      error: job.error || 'Unknown error occurred'
    });
  }

  // Return full result
  console.log(`[${new Date().toISOString()}] Job ${jobId} completed successfully, returning result`);
  res.json({
    jobId: job.jobId,
    status: job.status,
    result: job.result,
    sessionId: job.sessionId,
    createdAt: job.createdAt,
    completedAt: job.updatedAt
  });
});

// Process job asynchronously
async function processJob(jobId) {
  const job = jobs.get(jobId);
  if (!job) {
    console.error(`[${new Date().toISOString()}] Job ${jobId} not found in processJob`);
    return;
  }

  try {
    // Update status to processing
    job.status = JOB_STATUS.PROCESSING;
    job.updatedAt = new Date().toISOString();

    console.log(`[${new Date().toISOString()}] Processing job ${jobId}: ${job.inputText.substring(0, 100)}...`);

    // Get agent ARN from environment
    const agentRuntimeArn = process.env.AGENTCORE_AGENT_ARN ||
      'arn:aws:bedrock-agentcore:us-east-1:164543933824:runtime/bank_iq_agent_v1-rd5IAD3vrK';

    // Extract region from ARN (format: arn:aws:bedrock-agentcore:REGION:account:runtime/name)
    const region = agentRuntimeArn.split(':')[3] || 'us-east-1';
    const runtimeSessionId = job.sessionId || `session-${Date.now()}-${Math.random().toString(36).substring(2)}-${Math.random().toString(36).substring(2)}`;

    const payload = JSON.stringify({ prompt: job.inputText });
    const host = `bedrock-agentcore.${region}.amazonaws.com`;
    const path = `/runtimes/${encodeURIComponent(agentRuntimeArn)}/invocations`;

    console.log(`[${new Date().toISOString()}] Job ${jobId} - Calling AgentCore at ${host}${path}`);

    // Ensure credentials are loaded
    await new Promise((resolve, reject) => {
      AWS.config.getCredentials((err) => {
        if (err) {
          console.error(`[${new Date().toISOString()}] Job ${jobId} - AWS credentials error:`, err);
          reject(err);
        } else {
          console.log(`[${new Date().toISOString()}] Job ${jobId} - AWS credentials loaded`);
          resolve();
        }
      });
    });

    // Sign the request
    const endpoint = new AWS.Endpoint(host);
    const request = new AWS.HttpRequest(endpoint, region);

    request.method = 'POST';
    request.path = path;
    request.headers['Host'] = host;
    request.headers['Content-Type'] = 'application/json';
    request.headers['X-Amzn-Bedrock-AgentCore-Runtime-Session-Id'] = runtimeSessionId;
    request.body = payload;

    const signer = new AWS.Signers.V4(request, 'bedrock-agentcore');
    signer.addAuthorization(AWS.config.credentials, new Date());

    // Make HTTPS request (no timeout limit)
    const response = await new Promise((resolve, reject) => {
      const options = {
        hostname: host,
        path: request.path,
        method: request.method,
        headers: request.headers
      };

      const req = https.request(options, (res) => {
        let data = '';
        res.on('data', (chunk) => { data += chunk; });
        res.on('end', () => {
          console.log(`[${new Date().toISOString()}] Job ${jobId} - AgentCore response: ${res.statusCode}`);
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve({ statusCode: res.statusCode, body: data });
          } else {
            console.error(`[${new Date().toISOString()}] Job ${jobId} - AgentCore error ${res.statusCode}: ${data}`);
            reject(new Error(`HTTP ${res.statusCode}: ${data}`));
          }
        });
      });

      req.on('error', (err) => {
        console.error(`[${new Date().toISOString()}] Job ${jobId} - HTTPS request error:`, err);
        reject(err);
      });

      req.write(payload);
      req.end();
    });

    // Parse response
    const result = JSON.parse(response.body);
    let output = 'No response';
    if (result.content && Array.isArray(result.content) && result.content[0]?.text) {
      output = result.content[0].text;
    } else if (result.output) {
      output = result.output;
    } else if (result.response) {
      output = result.response;
    } else if (result.message) {
      output = result.message;
    } else if (typeof result === 'string') {
      output = result;
    } else {
      output = result.analysis || result.text || result.content || 'No response available';
    }

    // Update job with result
    job.status = JOB_STATUS.COMPLETED;
    job.result = output;
    job.sessionId = runtimeSessionId;
    job.updatedAt = new Date().toISOString();

    console.log(`[${new Date().toISOString()}] Job ${jobId} completed successfully (${output.length} chars)`);

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Job ${jobId} failed:`, {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    job.status = JOB_STATUS.FAILED;
    job.error = `${error.name}: ${error.message}`;
    job.updatedAt = new Date().toISOString();
  }
}

// Cleanup old jobs (run every 10 minutes)
setInterval(() => {
  const now = Date.now();
  const maxAge = 30 * 60 * 1000; // 30 minutes

  for (const [jobId, job] of jobs.entries()) {
    const jobAge = now - new Date(job.createdAt).getTime();
    if (jobAge > maxAge) {
      jobs.delete(jobId);
      console.log(`[${new Date().toISOString()}] Cleaned up old job: ${jobId}`);
    }
  }
}, 10 * 60 * 1000);


app.listen(PORT, () => {
  console.log(`✅ BankIQ+ Backend running on port ${PORT}`);
  console.log(`   Health check: http://localhost:${PORT}/health`);
  console.log(`   Chat API (async): http://localhost:${PORT}/api/chat`);
  console.log(`   Agent API (direct): http://localhost:${PORT}/api/invoke-agent`);
  console.log(`   Async Jobs: http://localhost:${PORT}/api/jobs/submit`);
  console.log(`   CSV Storage: http://localhost:${PORT}/api/store-csv-data`);
  console.log(`   CSV Analysis: http://localhost:${PORT}/api/analyze-local-data`);
  console.log(`   Bank Search: http://localhost:${PORT}/api/search-banks`);
});
